#-*- coding:utf-8 -*-

import numpy as np
from numpy import cos, sin
import baxter_link
from baxter_link import Baxter_Link



PI = np.pi
g = 9.81
FREQUENCY = 50.0 #Hz

links = {
    1: Baxter_Link(1,
                [0.0470910226, 0.035959884, 0.0376697645, -0.0061487003, -0.0007808689, 0.0001278755],
                [-0.05117, 0.07908, 0.00086],
                [0.2703, 0.069, -1*PI/2.0, 5.70044]
    ),
    2: Baxter_Link(2,
                [0.027885975, 0.020787492, 0.0117520941, -0.0001882199, 0.0020767576, -0.00030096397],
                [0.00269, -0.00529, 0.06845],
                [0, 0, PI/2.0, 3.22698]
    ),
    3: Baxter_Link(3,
                [0.0266173355, 0.012480083, 0.0284435520, -0.0039218988, -0.001083893, 0.0002927063],
                [-0.07176, 0.08149, 0.00132],
                [0.3644, 0.069, -PI/2, 4.31272]
    ),
    4: Baxter_Link(4,
                [0.0131822787, 0.009268520, 0.0071158268, -0.0001966341, 0.000745949, 0.0003603617],
                [0.00159, -0.01117, 0.02618],
                [0, 0, PI/2, 2.07206]
    ),
    5: Baxter_Link(5,
                [0.0166774282, 0.003746311, 0.0167545726, -0.0001865762, 0.0006473235, 0.0001840370],
                [-0.01168, 0.13111, 0.0046],
                [0.3743, 0.01, -PI/2, 2.24665]
    ),
    6: Baxter_Link(6,
                [0.0070053791, 0.005527552, 0.0038760715, 0.0001534806, -0.0002111503, -0.0004438478],
                [0.00697, 0.006, 0.06048],
                [0, 0, PI/2, 1.60979]
    ),
    7: Baxter_Link(7,
                [0.0008162135, 0.0008735012, 0.0005494148, 0.000128440, 0.0001057726, 0.00018969891],
                [0.005137, 0.0009572, -0.06682],
                [0.2295, 0, 0, 0.54218]
    )
}


def function1(sim_time = 40):
    #T = 3s
    dp = []
    p = []
    for t in xrange(int(sim_time*FREQUENCY+2)):
        y = sin(2*PI/3.0/FREQUENCY*(t-1))
        z = np.sqrt(1.0-y**2)
        x = 0.0
        p.append([x, y, z])

        
    for i in range(len(p)-2):
        dx = (p[i+2][0] - p[i][0])/2.0*FREQUENCY
        dy = (p[i+2][1] - p[i][1])/2.0*FREQUENCY
        dz = (p[i+2][2] - p[i][2])/2.0*FREQUENCY
        dp.append([dx, dy, dz])

    p = p[1:len(p)-1]
    
    dp = np.matrix(dp)
    p = np.matrix(p)

    return p, dp

    

def sim():
    K, P = range(2)
    L = K + P
    print L


def main():
    sim()
    p, dp = function1()

if __name__ == "__main__":
    main()
